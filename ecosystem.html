<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü¶ä Ecosystem Simulation üê∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a202c;
            color: white;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 28px;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: #2d3748;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #4a5568;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 14px;
        }
        
        textarea {
            width: 100%;
            height: 180px;
            background: #1a202c;
            color: #68d391;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            padding: 10px;
            border: 1px solid #4a5568;
            border-radius: 4px;
            resize: vertical;
        }
        
        button {
            background: #3182ce;
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 600;
        }
        
        button:hover {
            background: #2c5aa0;
        }
        
        button:disabled {
            background: #4a5568;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        button.pause {
            background: #e53e3e;
        }
        
        button.pause:hover {
            background: #c53030;
        }
        
        button.reset {
            background: #38a169;
        }
        
        button.reset:hover {
            background: #2f855a;
        }
        
        .stats {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .stat-item {
            background: #1a202c;
            padding: 12px;
            border-radius: 6px;
            min-width: 140px;
            border: 1px solid #4a5568;
        }
        
        .stat-label {
            font-size: 12px;
            color: #a0aec0;
            margin-bottom: 4px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
        }
        
        .ecosystem-grid {
            display: inline-grid;
            border: 2px solid #4a5568;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        .ecosystem-wrapper {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        .grid-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border: 1px solid #2d3748;
            transition: all 0.2s;
        }
        
        .cell-empty { background: #1a202c; }
        .cell-rock { background: #4a5568; }
        .cell-rabbit { background: #38a169; }
        .cell-fox { background: #dd6b20; }
        
        .chart-container {
            margin-top: 20px;
        }
        
        .chart {
            height: 120px;
            display: flex;
            align-items: flex-end;
            gap: 2px;
            padding: 10px;
            background: #1a202c;
            border-radius: 4px;
            overflow-x: auto;
            border: 1px solid #4a5568;
        }
        
        .chart-bar {
            flex: 1;
            min-width: 8px;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            gap: 1px;
        }
        
        .chart-rabbit {
            background: #38a169;
            transition: height 0.3s;
        }
        
        .chart-fox {
            background: #dd6b20;
            transition: height 0.3s;
        }
        
        .output {
            background: #1a202c;
            color: #68d391;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #4a5568;
            white-space: pre-wrap;
            max-height: 250px;
            overflow-y: auto;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            margin: 15px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            padding: 6px 12px;
            background: #2d3748;
            border-radius: 6px;
            border: 1px solid #4a5568;
        }
        
        .legend-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 12px 0;
        }
        
        input[type="range"] {
            flex: 1;
            max-width: 200px;
        }
        
        .chart-legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
            font-size: 12px;
        }
        
        .chart-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .chart-legend-color {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü¶ä Ecosystem Simulation üê∞</h1>
        
        <div class="controls-grid">
            <div class="panel">
                <label>Input Configuration:</label>
                <textarea id="inputText">2 4 3 6 5 5 9
ROCK 0 0
RABBIT 0 2
FOX 0 4
FOX 1 0
FOX 1 4
ROCK 2 4
RABBIT 3 0
RABBIT 4 0
FOX 4 4</textarea>
                <button class="reset" onclick="resetSimulation()">üîÑ Load/Reset</button>
            </div>
            
            <div class="panel">
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Generation</div>
                        <div class="stat-value" id="genCounter" style="color: #f6e05e;">0 / 0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">üê∞ Rabbits</div>
                        <div class="stat-value" id="rabbitCount" style="color: #68d391;">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">ü¶ä Foxes</div>
                        <div class="stat-value" id="foxCount" style="color: #f6ad55;">0</div>
                    </div>
                </div>
                
                <div>
                    <button id="playPauseBtn" onclick="togglePlayPause()">‚ñ∂Ô∏è Play</button>
                    <button id="stepBtn" onclick="stepSimulation()">‚è≠Ô∏è Step</button>
                </div>
                
                <div class="speed-control">
                    <span>Speed:</span>
                    <input type="range" id="speedSlider" min="50" max="1000" value="500" oninput="updateSpeed(this.value)">
                    <span id="speedValue">500ms</span>
                </div>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-icon cell-rock">ü™®</div>
                <span>Rock</span>
            </div>
            <div class="legend-item">
                <div class="legend-icon cell-rabbit">üê∞</div>
                <span>Rabbit</span>
            </div>
            <div class="legend-item">
                <div class="legend-icon cell-fox">ü¶ä</div>
                <span>Fox</span>
            </div>
            <div class="legend-item">
                <div class="legend-icon cell-empty"></div>
                <span>Empty</span>
            </div>
        </div>

        <div class="ecosystem-wrapper">
            <div id="ecosystemContainer" class="ecosystem-grid"></div>
        </div>

        <div class="panel chart-container">
            <label>Population Chart:</label>
            <div id="chartContainer" class="chart"></div>
            <div class="chart-legend">
                <div class="chart-legend-item">
                    <div class="chart-legend-color" style="background: #38a169;"></div>
                    <span>Rabbits</span>
                </div>
                <div class="chart-legend-item">
                    <div class="chart-legend-color" style="background: #dd6b20;"></div>
                    <span>Foxes</span>
                </div>
            </div>
        </div>

        <div class="panel">
            <label>Output:</label>
            <div id="output" class="output"></div>
        </div>
    </div>

    <script>
        const EMPTY = 0, ROCK = 1, RABBIT = 2, FOX = 3;
        const dx = [0, 1, 0, -1];
        const dy = [-1, 0, 1, 0];

        let params = null;
        let world = null;
        let rabbits = [];
        let foxes = [];
        let rocks = [];
        let currentGen = 0;
        let isRunning = false;
        let simulationSpeed = 500;
        let stats = [];
        let simulationInterval = null;

        function parseInput(text) {
            const lines = text.trim().split('\n');
            const [gpr, gpf, gff, ngen, r, c, n] = lines[0].split(' ').map(Number);
            const grid = Array(r).fill(null).map(() => Array(c).fill(EMPTY));
            const rabs = [], fxs = [], rks = [];
            
            for (let i = 1; i <= n; i++) {
                const [obj, fila, col] = lines[i].split(' ');
                const f = parseInt(fila), co = parseInt(col);
                
                if (obj === 'ROCK') {
                    grid[f][co] = ROCK;
                    rks.push({ x: co, y: f });
                } else if (obj === 'RABBIT') {
                    grid[f][co] = RABBIT;
                    rabs.push({ x: co, y: f, procAge: 0, hunger: 0, alive: true });
                } else if (obj === 'FOX') {
                    grid[f][co] = FOX;
                    fxs.push({ x: co, y: f, procAge: 0, hunger: 0, alive: true });
                }
            }
            
            return { 
                params: { gpr, gpf, gff, ngen, r, c }, 
                world: grid, 
                rabbits: rabs, 
                foxes: fxs, 
                rocks: rks 
            };
        }

        function simulateGeneration() {
            if (!world || !params || currentGen >= params.ngen) return null;
            
            const { gpr, gpf, gff, r, c } = params;
            let grid = world.map(row => [...row]);
            let newRabs = rabbits.map(r => ({...r}));
            let newFxs = foxes.map(f => ({...f}));
            
            // Solo procesar animales que ya exist√≠an (no reci√©n nacidos)
            const initialRabbitCount = newRabs.length;
            const initialFoxCount = newFxs.length;
            
            // === RABBITS ===
            const rabMovements = new Map();
            const willReproduce = new Map();
            
            for (let i = 0; i < initialRabbitCount; i++) {
                if (!newRabs[i].alive) continue;
                
                const { x, y } = newRabs[i];
                const available = [];
                for (let d = 0; d < 4; d++) {
                    const nx = x + dx[d], ny = y + dy[d];
                    if (nx >= 0 && nx < c && ny >= 0 && ny < r && grid[ny][nx] === EMPTY)
                        available.push([nx, ny]);
                }
                
                const dest = available.length > 0 
                    ? available[(currentGen + x + y) % available.length]
                    : [x, y];
                
                const key = `${dest[0]},${dest[1]}`;
                if (!rabMovements.has(key)) rabMovements.set(key, []);
                rabMovements.get(key).push(i);
                
                const moved = dest[0] !== x || dest[1] !== y;
                if (moved && newRabs[i].procAge >= gpr) {
                    willReproduce.set(i, [x, y]);
                }
            }
            
            for (let i = 0; i < initialRabbitCount; i++) {
                if (newRabs[i].alive) grid[newRabs[i].y][newRabs[i].x] = EMPTY;
            }
            
            const offspringRab = [];
            for (const [key, indices] of rabMovements) {
                const [destX, destY] = key.split(',').map(Number);
                
                if (indices.length === 1) {
                    const idx = indices[0];
                    const oldPos = willReproduce.get(idx);
                    
                    if (oldPos) {
                        offspringRab.push(oldPos);
                        newRabs[idx].procAge = 0;
                    }
                    
                    newRabs[idx].x = destX;
                    newRabs[idx].y = destY;
                    if (!oldPos) newRabs[idx].procAge++;
                    grid[destY][destX] = RABBIT;
                    
                } else {
                    let winner = indices[0];
                    for (const idx of indices) {
                        if (newRabs[idx].procAge > newRabs[winner].procAge) winner = idx;
                    }
                    
                    for (const idx of indices) {
                        if (idx !== winner) newRabs[idx].alive = false;
                    }
                    
                    const oldPos = willReproduce.get(winner);
                    if (oldPos) {
                        offspringRab.push(oldPos);
                        newRabs[winner].procAge = 0;
                    }
                    
                    newRabs[winner].x = destX;
                    newRabs[winner].y = destY;
                    if (!oldPos) newRabs[winner].procAge++;
                    grid[destY][destX] = RABBIT;
                }
            }
            
            for (const [x, y] of offspringRab) {
                if (grid[y][x] === EMPTY) {
                    newRabs.push({ x, y, procAge: 0, hunger: 0, alive: true });
                    grid[y][x] = RABBIT;
                }
            }
            
            // === FOXES ===
            for (let i = 0; i < initialFoxCount; i++) {
                if (newFxs[i].alive) newFxs[i].hunger++;
            }
            
            const canEat = new Map();
            for (let i = 0; i < initialFoxCount; i++) {
                if (!newFxs[i].alive) continue;
                
                const { x, y } = newFxs[i];
                let hasRabbit = false;
                for (let d = 0; d < 4; d++) {
                    const nx = x + dx[d], ny = y + dy[d];
                    if (nx >= 0 && nx < c && ny >= 0 && ny < r && grid[ny][nx] === RABBIT) {
                        hasRabbit = true;
                        break;
                    }
                }
                canEat.set(i, hasRabbit);
            }
            
            for (let i = 0; i < initialFoxCount; i++) {
                if (newFxs[i].alive && newFxs[i].hunger >= gff && !canEat.get(i)) {
                    newFxs[i].alive = false;
                }
            }
            
            const reproduced = new Map();
            const offspringFox = [];
            for (let i = 0; i < initialFoxCount; i++) {
                if (!newFxs[i].alive) continue;
                
                if (newFxs[i].procAge >= gpf) {
                    offspringFox.push([newFxs[i].x, newFxs[i].y]);
                    newFxs[i].procAge = 0;
                    reproduced.set(i, true);
                } else {
                    reproduced.set(i, false);
                }
            }
            
            const foxMovements = new Map();
            for (let i = 0; i < initialFoxCount; i++) {
                if (!newFxs[i].alive) continue;
                
                const { x, y } = newFxs[i];
                const adjRabbits = [];
                for (let d = 0; d < 4; d++) {
                    const nx = x + dx[d], ny = y + dy[d];
                    if (nx >= 0 && nx < c && ny >= 0 && ny < r && grid[ny][nx] === RABBIT)
                        adjRabbits.push([nx, ny]);
                }
                
                let dest;
                if (adjRabbits.length > 0) {
                    dest = adjRabbits[0];
                } else {
                    const available = [];
                    for (let d = 0; d < 4; d++) {
                        const nx = x + dx[d], ny = y + dy[d];
                        if (nx >= 0 && nx < c && ny >= 0 && ny < r && grid[ny][nx] === EMPTY)
                            available.push([nx, ny]);
                    }
                    dest = available.length > 0 ? available[(currentGen + x + y) % available.length] : [x, y];
                }
                
                const key = `${dest[0]},${dest[1]}`;
                if (!foxMovements.has(key)) foxMovements.set(key, []);
                foxMovements.get(key).push(i);
            }
            
            for (let i = 0; i < initialFoxCount; i++) {
                if (newFxs[i].alive) grid[newFxs[i].y][newFxs[i].x] = EMPTY;
            }
            
            for (const [key, indices] of foxMovements) {
                const [destX, destY] = key.split(',').map(Number);
                
                let rabbitAtDest = false;
                for (const r of newRabs) {
                    if (r.alive && r.x === destX && r.y === destY) {
                        r.alive = false;
                        rabbitAtDest = true;
                        break;
                    }
                }
                
                if (indices.length === 1) {
                    const idx = indices[0];
                    if (rabbitAtDest) newFxs[idx].hunger = 0;
                    
                    newFxs[idx].x = destX;
                    newFxs[idx].y = destY;
                    if (!reproduced.get(idx)) newFxs[idx].procAge++;
                    grid[destY][destX] = FOX;
                    
                } else {
                    let winner = indices[0];
                    for (const idx of indices) {
                        const a = newFxs[idx], b = newFxs[winner];
                        if (a.procAge > b.procAge || (a.procAge === b.procAge && a.hunger < b.hunger))
                            winner = idx;
                    }
                    
                    for (const idx of indices) {
                        if (idx !== winner) newFxs[idx].alive = false;
                    }
                    
                    if (rabbitAtDest) newFxs[winner].hunger = 0;
                    newFxs[winner].x = destX;
                    newFxs[winner].y = destY;
                    if (!reproduced.get(winner)) newFxs[winner].procAge++;
                    grid[destY][destX] = FOX;
                }
            }
            
            for (const [x, y] of offspringFox) {
                if (grid[y][x] === EMPTY) {
                    newFxs.push({ x, y, procAge: 0, hunger: 0, alive: true });
                    grid[y][x] = FOX;
                }
            }
            
            // Reconstruir el grid desde cero para asegurar consistencia
            for (let i = 0; i < r; i++) {
                for (let j = 0; j < c; j++) {
                    if (grid[i][j] !== ROCK) {
                        grid[i][j] = EMPTY;
                    }
                }
            }
            
            // Colocar solo los animales vivos
            for (const rb of newRabs) {
                if (rb.alive) {
                    grid[rb.y][rb.x] = RABBIT;
                }
            }
            
            for (const fx of newFxs) {
                if (fx.alive) {
                    grid[fx.y][fx.x] = FOX;
                }
            }
            
            return { world: grid, rabbits: newRabs, foxes: newFxs };
        }

        function renderWorld() {
            if (!world || !params) return;
            
            const { r, c } = params;
            const cellSize = Math.min(50, 500 / Math.max(r, c));
            
            const container = document.getElementById('ecosystemContainer');
            container.style.gridTemplateColumns = `repeat(${c}, ${cellSize}px)`;
            container.innerHTML = '';
            
            for (let i = 0; i < r; i++) {
                for (let j = 0; j < c; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    
                    switch (world[i][j]) {
                        case ROCK:
                            cell.classList.add('cell-rock');
                            cell.textContent = 'ü™®';
                            break;
                        case RABBIT:
                            cell.classList.add('cell-rabbit');
                            cell.textContent = 'üê∞';
                            break;
                        case FOX:
                            cell.classList.add('cell-fox');
                            cell.textContent = 'ü¶ä';
                            break;
                        default:
                            cell.classList.add('cell-empty');
                            break;
                    }
                    
                    cell.style.width = `${cellSize}px`;
                    cell.style.height = `${cellSize}px`;
                    container.appendChild(cell);
                }
            }
        }

        function updateStatistics() {
            if (!params) return;
            
            const rabbitCount = rabbits.filter(r => r.alive).length;
            const foxCount = foxes.filter(f => f.alive).length;
            
            document.getElementById('genCounter').textContent = `${currentGen} / ${params.ngen}`;
            document.getElementById('rabbitCount').textContent = rabbitCount;
            document.getElementById('foxCount').textContent = foxCount;
            
            stats.push({ gen: currentGen, rabbits: rabbitCount, foxes: foxCount });
            if (stats.length > 100) stats.shift();
            
            renderChart();
        }

        function renderChart() {
            const container = document.getElementById('chartContainer');
            container.innerHTML = '';
            
            if (stats.length < 2) return;
            
            const maxRabbits = Math.max(...stats.map(s => s.rabbits), 1);
            const maxFoxes = Math.max(...stats.map(s => s.foxes), 1);
            const maxPop = Math.max(maxRabbits, maxFoxes);
            
            const displayStats = stats.slice(-100); // Mostrar √∫ltimas 100 generaciones
            
            displayStats.forEach(stat => {
                const bar = document.createElement('div');
                bar.className = 'chart-bar';
                
                const rabbitBar = document.createElement('div');
                rabbitBar.className = 'chart-rabbit';
                rabbitBar.style.height = `${(stat.rabbits / maxPop) * 90}px`;
                rabbitBar.title = `Gen ${stat.gen}: ${stat.rabbits} rabbits`;
                
                const foxBar = document.createElement('div');
                foxBar.className = 'chart-fox';
                foxBar.style.height = `${(stat.foxes / maxPop) * 90}px`;
                foxBar.title = `Gen ${stat.gen}: ${stat.foxes} foxes`;
                
                bar.appendChild(rabbitBar);
                bar.appendChild(foxBar);
                container.appendChild(bar);
            });
        }

        function getOutput() {
            if (!world || !params) return '';
            
            const { gpr, gpf, gff, r, c } = params;
            let count = rocks.length + rabbits.filter(r => r.alive).length + foxes.filter(f => f.alive).length;
            let lines = [`${gpr} ${gpf} ${gff} 0 ${r} ${c} ${count}`];
            
            for (const rk of rocks) lines.push(`ROCK ${rk.y} ${rk.x}`);
            for (const rb of rabbits) if (rb.alive) lines.push(`RABBIT ${rb.y} ${rb.x}`);
            for (const fx of foxes) if (fx.alive) lines.push(`FOX ${fx.y} ${fx.x}`);
            
            return lines.join('\n');
        }

        function resetSimulation() {
            isRunning = false;
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
            }
            
            try {
                const inputText = document.getElementById('inputText').value;
                const result = parseInput(inputText);
                
                params = result.params;
                world = result.world;
                rabbits = result.rabbits;
                foxes = result.foxes;
                rocks = result.rocks;
                currentGen = 0;
                stats = [];
                
                renderWorld();
                updateStatistics();
                document.getElementById('output').textContent = getOutput();
                
                document.getElementById('playPauseBtn').textContent = '‚ñ∂Ô∏è Play';
                document.getElementById('playPauseBtn').classList.remove('pause');
                document.getElementById('stepBtn').disabled = false;
                
            } catch (error) {
                alert('Error: Invalid input format');
                console.error(error);
            }
        }

        function stepSimulation() {
            if (!world || !params || currentGen >= params.ngen) return;
            
            const result = simulateGeneration();
            if (result) {
                world = result.world;
                rabbits = result.rabbits;
                foxes = result.foxes;
                currentGen++;
                
                renderWorld();
                updateStatistics();
                document.getElementById('output').textContent = getOutput();
                
                if (currentGen >= params.ngen) {
                    isRunning = false;
                    if (simulationInterval) {
                        clearInterval(simulationInterval);
                        simulationInterval = null;
                    }
                    document.getElementById('playPauseBtn').textContent = '‚ñ∂Ô∏è Play';
                    document.getElementById('playPauseBtn').classList.remove('pause');
                    document.getElementById('stepBtn').disabled = false;
                }
            }
        }

        function togglePlayPause() {
            isRunning = !isRunning;
            
            if (isRunning) {
                document.getElementById('playPauseBtn').textContent = '‚è∏Ô∏è Pause';
                document.getElementById('playPauseBtn').classList.add('pause');
                document.getElementById('stepBtn').disabled = true;
                
                simulationInterval = setInterval(() => {
                    if (currentGen >= params.ngen) {
                        togglePlayPause();
                        return;
                    }
                    stepSimulation();
                }, simulationSpeed);
                
            } else {
                document.getElementById('playPauseBtn').textContent = '‚ñ∂Ô∏è Play';
                document.getElementById('playPauseBtn').classList.remove('pause');
                document.getElementById('stepBtn').disabled = false;
                if (simulationInterval) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                }
            }
        }

        function updateSpeed(value) {
            simulationSpeed = 1050 - value;
            document.getElementById('speedValue').textContent = `${simulationSpeed}ms`;
            
            if (isRunning) {
                clearInterval(simulationInterval);
                simulationInterval = setInterval(stepSimulation, simulationSpeed);
            }
        }

        window.addEventListener('DOMContentLoaded', function() {
            resetSimulation();
        });
    </script>
</body>
</html>